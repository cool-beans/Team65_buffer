from django.db import models

# User class for built-in authentication module
from django.contrib.auth.models import User

class Membership(models.Model):
    # Many members with a Membership
    # Many Memberships are allowed in many events
    name = models.CharField(max_length=20)
    #allowed_events = models.ManyToManyField(Event)
    allowed_freq = models.IntegerField()
    price = models.DecimalField(max_digits=7, decimal_places=2)

    def __unicode__(self):
        return self.name

class Member(models.Model):
    # Members can be Staff
    # Many Members can attend many Events
    # Many Members can be part of many Programs
    # Members have many Attendence for events
    user = models.OneToOneField(User)
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    birthday = models.DateField()

    phone = models.CharField(max_length=10)
    email = models.CharField(max_length=30)

    staff = models.BooleanField(default=False)

    creation_date = models.DateField()
    membership = models.ForeignKey(Membership, null=True, blank=True)
    membership_exp_date = models.DateField(null=True, blank=True)
    #programs = models.ManyToManyField(Program)
    #events = models.ManyToManyField(Event)

    def __unicode__(self):
        return self.first_name + " " + self.last_name

class Program(models.Model):
    # Many EventTypes in many Programs
    name = models.CharField(max_length=20)
    description = models.CharField(max_length=500)
    members = models.ManyToManyField(Member)

    def __unicode__(self):
        return self.name

class Recurrence(models.Model):
    # Associated with one EventType
    onSundays = models.BooleanField(default=False)
    onMondays = models.BooleanField(default=False)
    onTuesdays = models.BooleanField(default=False)
    onWednesdays = models.BooleanField(default=False)
    onThursdays = models.BooleanField(default=False)
    onFridays = models.BooleanField(default=False)
    onSaturdays = models.BooleanField(default=False)

    isRecurring = models.BooleanField(default=False)

    start_date = models.DateField()
    end_date = models.DateField(null=True, blank=True)

    def __unicode__(self):
        return self.EventType.name + "'s Recurrence"

    def setDayRecurrence(self, day, isRecurring):

        if day == 0:
            self.onMondays = isRecurring
        elif day == 1:
            self.onTuesdays = isRecurring
        elif day == 2:
            self.onWednesdays = isRecurring
        elif day == 3:
            self.onThursdays = isRecurring
        elif day == 4:
            self.onFridays = isRecurring
        elif day == 5:
            self.onSaturdays = isRecurring
        elif day == 6:
            self.onSundays = isRecurring

    def getDays(self):
        days = []

        if self.onMondays:
            days.append(0)
        if self.onTuesdays:
            days.append(1)
        if self.onWednesdays:
            days.append(2)
        if self.onThursdays:
            days.append(3)
        if self.onFridays:
            days.append(4)
        if self.onSaturdays:
            days.append(5)
        if self.onSundays:
            days.append(6)

        return days

class EventType(models.Model):
    # Has many Events associated with one EventType
    name = models.CharField(max_length=20)
    programs = models.ManyToManyField(Program)
    start_time = models.TimeField()
    end_time = models.TimeField()
    note = models.CharField(max_length=500, blank=True)
    recurrence = models.OneToOneField(Recurrence)
    #allowed_memberships = models.ManyToManyField(Membership)

    def __unicode__(self):
        return self.name

# This is the physical calender event generated by an EventType
# which may repeatedly generate events (i.e. for every Tuesday)
# Otherwise, how would you delete a recurring event
# for just one day?
class Event(models.Model):
    # Events are associated with an EventType
    name = models.CharField(max_length=20)
    date = models.DateField()
    start_time = models.TimeField()
    end_time = models.TimeField()
    note = models.CharField(max_length=500, blank=True)
    attendees = models.ManyToManyField(Member, null=True, blank=True)
    event_type = models.ForeignKey(EventType)
    is_cancelled = models.BooleanField(default=False)

    def __unicode__(self):
        return self.name

    # Given name, date, start_time of an event,
    # find the specified event if it exists (or create a temp one)
    # and return it. 
    # First check Events.objects, if no such event exists, 
    # Second, find proper EventType and create a temp Event
    # Third, if no EventType matches, then return None
    def getEvent(self, name, date, start_time):
        
        event = None
        found_event = None
        new_event = None
        event = Event.objects.filter(name=name).filter(date=date).filter(start_time=start_time)

        if event and len(event)==1:
            return event[0]
        
        eventtypes = EventType.objects.filter(name=name).filter(start_time=start_time)

        for eventtype in eventtypes:
            # If the event started before or on date and either has no 
            if eventtype.recurrence.start_date <= date:
                weekday = date.weekday
                # If event's weekday was in eventtype's weekdays
                if weekday in eventtype.recurrence.getDays():
                    found_event = eventtype.event_set.filter(date=date)
                    # If eventtype already had an event that exactly matched, set event
                    if found_event:
                        event = found_event
                        break
                    # Otherwise, create an event
                    else:
                        new_event = Event(name=new_eventtype.name,
                          date=new_eventtype.recurrence.start_date,
                          start_time=new_eventtype.start_time,
                          end_time=new_eventtype.end_time,
                          note=new_eventtype.note,
                          event_type = new_eventtype)
                        break


class Attendance(models.Model):
    member = models.ForeignKey(Member)
    event = models.ForeignKey(Event)
    sign_in_time = models.TimeField()

    def __unicode__(self):
        return self.sign_in_time
